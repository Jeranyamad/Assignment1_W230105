1. Lexer (Flex)

A lexer is responsible for reading the input source code and tokenizing it based on predefined patterns. The provided `lexer.l` code uses Flex to define tokens for keywords, operators, identifiers, integers, and floats.

2. Parser (Yacc/Bison)

The parser processes the tokens generated by the lexer. The provided `parser.y` code defines grammar rules and semantic actions for constructing parse trees.

3. Semantic Actions

These are actions taken during the parsing process, typically involving handling data for the parse tree or managing symbol tables.

Steps to Implement the Parser

Step 1: Installed Flex and Bison

I ensured that i installed Flex and Bison are installed on my system and added them to the correct path in system variables after downloading them an a gcc compiler:


Step 2: Create Lexer (`lexer.l`)

The lexer defined the tokens I passed to the parser. Here’s a brief breakdown:

```flex
%{
#include "y.tab.h"
%}

%%
"int"           { return INT; }
"return"        { return RETURN; }
"if"            { return IF; }
...
[a-zA-Z_][a-zA-Z0-9_]*  { yylval.sval = strdup(yytext); return IDENTIFIER; }
[0-9]+           { yylval.ival = atoi(yytext); return INTEGER; }
[0-9]+"."[0-9]* { yylval.fval = atof(yytext); return FLOAT; }
...
.               { printf("Unknown character: %s\n", yytext); }
%%
```

Step 3: Create Parser (`parser.y`)

I defined the grammar rules and actions. Here’s the core structure:

```yacc
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void yyerror(const char *s);
int yylex(void);
%}

%union {
    int ival;
    float fval;
    char *sval;
}

// Token declarations
%token <ival> INTEGER
%token <fval> FLOAT
%token <sval> IDENTIFIER
%token INT RETURN IF ELSE WHILE FOR
...

%%
program:
    function
    ;

function:
    INT IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    ;
...
%%
```

Step 4: Compile the Lexer and Parser

You need to generate C code from the lexer and parser definitions and then compile it:

1. Generate the lexer:
   ```bash using command prompt
   flex lexer.l
   ```

2. Generate the parser:
   ```bash
   bison -d parser.y
   ```

3. Compile the generated C files:
   ```bash
   gcc lex.yy.c parser.tab.c -o parser -lfl
   ```

### Step 5: Run the Parser

You can now run your parser with an input file. For example:
```bash
./parser < input.txt
```

Replace `input.txt` with your test source code.

## Generating a Parse Tree

To generate a parse tree, you need to modify the semantic actions in your grammar:

1. Defined a Node Structure**:
   Create a structure to represent nodes in your parse tree.

```c
typedef struct Node {
    char *value;
    struct Node **children;
    int child_count;
} Node;

Node *create_node(char *value) {
    Node *node = malloc(sizeof(Node));
    node->value = strdup(value);
    node->children = NULL;
    node->child_count = 0;
    return node;
}
```

2. Modify Actions:
   Enhanced the grammar rules to create nodes in the parse tree.

```yacc
function:
    INT IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE {
        $$ = create_node("function");
        $$->children = malloc(sizeof(Node*) * 3);
        $$->children[0] = create_node($2); // Identifier
        $$->children[1] = $5; // Statements
        $$->child_count = 2;
    }
```

3. Print the Tree:
   Implemented a function to visualize the parse tree.

```c
void print_tree(Node *node, int level) {
    for (int i = 0; i < level; i++) printf("  ");
    printf("%s\n", node->value);
    for (int i = 0; i < node->child_count; i++) {
        print_tree(node->children[i], level + 1);
    }
}
```

4. Invoke `print_tree` in `yyerror`**:
   Call this function to v
